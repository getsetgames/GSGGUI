#strict on#target photoshop//------------////////////////////////////////////////////////////////////////////////////------------////------------///////////////////////// Get Set Games GUI Exporter ///////////////////////------------////------------// Unfortunately this is somewhat a rewrite of the old GUI exporter, this //------------////------------// should be more maintainable, have a better structure and expandability //------------////------------// Also, I am using Adobe's shitty... shitty editor, so formatting things //------------////------------// this way was the only way I could find to keep some order in here  :(  //------------////------------////////////////////////////////////////////////////////////////////////////------------////------------////////////////////////////////////////////////////////////////////////////------------////----------------------------------------------------------------------------------------------------////------------///////////////////////////////////------------////------------//////// JSON EXPORTER CODE ///////------------////------------///////////////////////////////////------------//// you CAN use importing in photoshop but it involves installing the libraries in the photoshop environment and would not be convenient //// Create a JSON object only if one does not already exist. We create the// methods in a closure to avoid creating global variables.var JSON;if (!JSON) {    JSON = {};}(function () {    "use strict";    function f(n) {        // Format integers to have at least two digits.        return n < 10 ? '0' + n : n;    }    if (typeof Date.prototype.toJSON !== 'function') {        Date.prototype.toJSON = function (key) {            return isFinite(this.valueOf()) ?                this.getUTCFullYear()     + '-' +                f(this.getUTCMonth() + 1) + '-' +                f(this.getUTCDate())      + 'T' +                f(this.getUTCHours())     + ':' +                f(this.getUTCMinutes())   + ':' +                f(this.getUTCSeconds())   + 'Z' : null;        };        String.prototype.toJSON      =            Number.prototype.toJSON  =            Boolean.prototype.toJSON = function (key) {                return this.valueOf();            };    }    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,        gap,        indent,        meta = {    // table of character substitutions            '\b': '\\b',            '\t': '\\t',            '\n': '\\n',            '\f': '\\f',            '\r': '\\r',            '"' : '\\"',            '\\': '\\\\'        },        rep;    function quote(string) {// If the string contains no control characters, no quote characters, and no// backslash characters, then we can safely slap some quotes around it.// Otherwise we must also replace the offending characters with safe escape// sequences.        escapable.lastIndex = 0;        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {            var c = meta[a];            return typeof c === 'string' ? c :                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);        }) + '"' : '"' + string + '"';    }    function str(key, holder) {// Produce a string from holder[key].        var i,          // The loop counter.            k,          // The member key.            v,          // The member value.            length,            mind = gap,            partial,            value = holder[key];// If the value has a toJSON method, call it to obtain a replacement value.        if (value && typeof value === 'object' &&                typeof value.toJSON === 'function') {            value = value.toJSON(key);        }// If we were called with a replacer function, then call the replacer to// obtain a replacement value.        if (typeof rep === 'function') {            value = rep.call(holder, key, value);        }// What happens next depends on the value's type.        switch (typeof value) {        case 'string':            return quote(value);        case 'number':// JSON numbers must be finite. Encode non-finite numbers as null.            return isFinite(value) ? String(value) : 'null';        case 'boolean':        case 'null':// If the value is a boolean or null, convert it to a string. Note:// typeof null does not produce 'null'. The case is included here in// the remote chance that this gets fixed someday.            return String(value);// If the type is 'object', we might be dealing with an object or an array or// null.        case 'object':// Due to a specification blunder in ECMAScript, typeof null is 'object',// so watch out for that case.            if (!value) {                return 'null';            }// Make an array to hold the partial results of stringifying this object value.            gap += indent;            partial = [];// Is the value an array?            if (Object.prototype.toString.apply(value) === '[object Array]') {// The value is an array. Stringify every element. Use null as a placeholder// for non-JSON values.                length = value.length;                for (i = 0; i < length; i += 1) {                    partial[i] = str(i, value) || 'null';                }// Join all of the elements together, separated with commas, and wrap them in// brackets.                v = partial.length === 0 ? '[]' : gap ?                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :                    '[' + partial.join(',') + ']';                gap = mind;                return v;            }// If the replacer is an array, use it to select the members to be stringified.            if (rep && typeof rep === 'object') {                length = rep.length;                for (i = 0; i < length; i += 1) {                    if (typeof rep[i] === 'string') {                        k = rep[i];                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            } else {// Otherwise, iterate through all of the keys in the object.                for (k in value) {                    if (Object.prototype.hasOwnProperty.call(value, k)) {                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            }// Join all of the member texts together, separated with commas,// and wrap them in braces.            v = partial.length === 0 ? '{}' : gap ?                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :                '{' + partial.join(',') + '}';            gap = mind;            return v;        }    }// If the JSON object does not yet have a stringify method, give it one.    if (typeof JSON.stringify !== 'function') {        JSON.stringify = function (value, replacer, space) {// The stringify method takes a value and an optional replacer, and an optional// space parameter, and returns a JSON text. The replacer can be a function// that can replace values, or an array of strings that will select the keys.// A default replacer method can be provided. Use of the space parameter can// produce text that is more easily readable.            var i;            gap = '';            indent = '';// If the space parameter is a number, make an indent string containing that// many spaces.            if (typeof space === 'number') {                for (i = 0; i < space; i += 1) {                    indent += ' ';                }// If the space parameter is a string, it will be used as the indent string.            } else if (typeof space === 'string') {                indent = space;            }// If there is a replacer, it must be a function or an array.// Otherwise, throw an error.            rep = replacer;            if (replacer && typeof replacer !== 'function' &&                    (typeof replacer !== 'object' ||                    typeof replacer.length !== 'number')) {                throw new Error('JSON.stringify');            }// Make a fake root object containing our value under the key of ''.// Return the result of stringifying the value.            return str('', {'': value});        };    }// If the JSON object does not yet have a parse method, give it one.    if (typeof JSON.parse !== 'function') {        JSON.parse = function (text, reviver) {// The parse method takes a text and an optional reviver function, and returns// a JavaScript value if the text is a valid JSON text.            var j;            function walk(holder, key) {// The walk method is used to recursively walk the resulting structure so// that modifications can be made.                var k, v, value = holder[key];                if (value && typeof value === 'object') {                    for (k in value) {                        if (Object.prototype.hasOwnProperty.call(value, k)) {                            v = walk(value, k);                            if (v !== undefined) {                                value[k] = v;                            } else {                                delete value[k];                            }                        }                    }                }                return reviver.call(holder, key, value);            }// Parsing happens in four stages. In the first stage, we replace certain// Unicode characters with escape sequences. JavaScript handles many characters// incorrectly, either silently deleting them, or treating them as line endings.            text = String(text);            cx.lastIndex = 0;            if (cx.test(text)) {                text = text.replace(cx, function (a) {                    return '\\u' +                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                });            }// In the second stage, we run the text against regular expressions that look// for non-JSON patterns. We are especially concerned with '()' and 'new'// because they can cause invocation, and '=' because it can cause mutation.// But just to be safe, we want to reject all unexpected forms.// We split the second stage into 4 regexp operations in order to work around// crippling inefficiencies in IE's and Safari's regexp engines. First we// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we// replace all simple value tokens with ']' characters. Third, we delete all// open brackets that follow a colon or comma or that begin the text. Finally,// we look to see that the remaining characters are only whitespace or ']' or// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.            if (/^[\],:{}\s]*$/                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {// In the third stage we use the eval function to compile the text into a// JavaScript structure. The '{' operator is subject to a syntactic ambiguity// in JavaScript: it can begin a block or an object literal. We wrap the text// in parens to eliminate the ambiguity.                j = eval('(' + text + ')');// In the optional fourth stage, we recursively walk the new structure, passing// each name/value pair to a reviver function for possible transformation.                return typeof reviver === 'function' ?                    walk({'': j}, '') : j;            }// If the text is not JSON parseable, then a SyntaxError is thrown.            throw new SyntaxError('JSON.parse');        };    }}());// END JSON//------------///////////////////////////////////------------////------------//////// JSON EXPORTER CODE ///////------------////------------///////////////////////////////////------------////----------------------------------------------------------------------------------------------------////------------///////////////////////////////////------------////------------////// STARTUP AND VARIABLES //////------------////------------///////////////////////////////////------------//var kName = "GSGGUIName";var kID = "GSGGUIID";var kClass = "GSGGUIClass";var kMisc = "GSGGUIMisc";var kPositionTypeHorizontal = "GSGGUIPositionTypeHorizontal";var kPositionTypeVertical = "GSGGUIPositionTypeVertical";var kRect = "GSGGUIRect";var kPosition = "GSGGUIPosition";var kXMPNamespace = "com.getsetgames.GSGGUI";// version number variable //// version number variable //var g_exporter_version = '2.0';// So it turns out that cached regular expressions are faster... and easier to read! //var g_regexp_layout         = new RegExp(/^layout-\b/);// call the script's main function ////scriptMain();//------------///////////////////////////////////------------////------------////// STARTUP AND VARIABLES //////------------////------------///////////////////////////////////------------////----------------------------------------------------------------------------------------------------////------------///////////////////////////////////------------////------------////////// MAIN FUNCTION //////////------------////------------///////////////////////////////////------------//function GSGGUI_export_dump(){	// setup exporting and logging //	setupLogging();		if (!app.documents.length)    {         alert('There are no documents open. Nothing to export.');		return;    }		var sourceFilePath = app.activeDocument.fullName.path + "/";        	openLog( sourceFilePath.toString().match(/([^\.]+)/)[1] + app.activeDocument.name.match(/([^\.]+)/)[1] + ".log" );	log('Starting export.')	var exportFolderName = sourceFilePath.toString().match(/([^\.]+)/)[1] + app.activeDocument.name.match(/([^\.]+)/)[1] + '_EXPORT/';	var exportFolder = new Folder(exportFolderName);	log('Exporting to folder "' + exportFolderName + '"');		if (!exportFolder.exists)	{		log('Export folder does not exist. Creating it.');		exportFolder.create();		if (!exportFolder.exists)		{			log('Unable to create export folder "' + exportFolderName + '"!');			return;		}	}    // hopefully this is not too slow //    // find the classes group //        var dump = [];    var layers = app.activeDocument.layers;        // iterate through the layerSets in the root and act accordingly //    for (var i = 0; i < layers.length; ++i)    {        var layer = layers[i];        // at this point we only care about groups so ignore any other layers //        if (layer.visible)        {            dump[dump.length] = processNode(layer, exportFolderName);        }        else        {            log("Skipping layer: " + layerSet.name);        }    }    //dump['document'] = processNode (app.activeDocument, exportFolderName);    var finalExport = {};        finalExport['exporter-version'] = g_exporter_version;    finalExport['export-name'] = app.activeDocument.name.match(/([^\.]+)/)[1];    finalExport['export-rect'] = "{ { 0, 0 }, { " + app.activeDocument.width.as('px') + ", " + app.activeDocument.height.as('px') + " } }";    finalExport['dump'] = dump;        var jsonFile = new File(sourceFilePath.toString().match(/([^\.]+)/)[1] + app.activeDocument.name.match(/([^\.]+)/)[1] + ".json");    jsonFile.open('w');    jsonFile.writeln(JSON.stringify(finalExport, null, '\t'));    jsonFile.close();        alert ("The export process is complete.", "Tadaaaaaa!");    }//------------///////////////////////////////////------------////------------////////// MAIN FUNCTION //////////------------////------------///////////////////////////////////------------////----------------------------------------------------------------------------------------------------////------------///////////////////////////////////------------////------------////// SUPPORTING FUNCTIONS ///////------------////------------///////////////////////////////////------------////----------------------------------------------------------------------------------------------------// Set up a closure over some related functions, so they can share variables without making all// those variables globals.//----------------------------------------------------------------------------------------------------function setupLogging(){    var indentLevel = 0;    var logFile;        indent = function()    {        indentLevel++;    }    outdent = function()    {        indentLevel = Math.max( 0, indentLevel - 1 );    }    openLog = function( filename )    {        logFile = new File( filename );        logFile.open( 'w' );    }    closeLog = function()    {        logFile.close();    }	indentString = function(number)	{		var ret = '';		for (var i = 0; i < number - 1; ++i)		{			ret += '|   ';		}		if (number)		{			ret += '|---';		}		return ret;	}    log = function( msg )    {        var ts = new Date();        logFile.write( ts + ': ' + indentString( indentLevel ) + msg + '\n' );    }    alertAndLog = function( msg )    {        alert( msg );        log( msg );    }}//----------------------------------------------------------------------------------------------------function exportLayerToFile(layer, exportFolder) {    var bounds = layer.bounds;    var name = layer.name;    var width = bounds[2] - bounds[0];    var height = bounds[3] - bounds[1];    var resolution = app.activeDocument.resolution;    indent();    log('Layer: "' + layer.name + '": width = ' + width + ', height = ' + height + ', resolution = ' + resolution);    indent();    // We'll merge the current layer down into a new empty layer that we create.    // We do this because otherwise we can't copy some kinds of complicated layers.        log('copying layer "' + layer.name +  '"...');    var layerCopy = layer.duplicate();    log('creating new empty layer to merge down to.');    var mergedLayer = app.activeDocument.artLayers.add();    log('moving new layer below copied layer.');    mergedLayer.move(layerCopy, ElementPlacement.PLACEAFTER);    log('merging copied layer down.');    mergedLayer = layerCopy.merge();    mergedLayer.name = name;         if (mergedLayer)    {        // Copy layer to clipboard        log('copying merged layer to clipboard.');        mergedLayer.copy();                // Create a new file that we'll copy the layer into        log('creating new document to paste into.');        var exportedDoc = app.documents.add(width, height, resolution, app.activeDocument.name + '_LAYER_TEMP', NewDocumentMode.RGB, DocumentFill.TRANSPARENT, 1);                log('pasting clipboard copy of merged layer into new document.');        exportedDoc.paste();                var exportedFilename = exportFolder + name + '.png';        log('saving layer as PNG file "' + exportedFilename + '"');        var exportedFile = new File(exportedFilename);        exportedDoc.saveAs(exportedFile, new PNGSaveOptions());                // don’t save anything we did         log('discarding temporary document.');        exportedDoc.close(SaveOptions.DONOTSAVECHANGES);        log('removing merged layer copy.');        mergedLayer.remove();    }	outdent();	outdent();}//----------------------------------------------------------------------------------------------------function processAssets(group, exportFolder){    var layers = group.layers;	for (var i = 0; i < layers.length; ++i)	{        var layer = layers[i];		if (layer.visible)		{            if (layer.typename == "LayerSet")            {                processAssets (layer, exportFolder);            }            else            {                exportLayerToFile(layer, exportFolder);            }		}			else		{			log("Skipping invisible layer: " + layers[i].name);		}	}}//----------------------------------------------------------------------------------------------------function processNode(node, exportFolder){	indent();	var ret = {};        // make the node the current layer //    app.activeDocument.activeLayer = node;        // get the layer metadata //    var layerName = getLayerMetadata(kName);    var layerID = getLayerMetadata(kID);    var layerClass = getLayerMetadata(kClass);    var layerMisc = getLayerMetadata(kMisc);    var layerRect = getLayerMetadata(kRect);    var layerPosition = getLayerMetadata(kPosition);    var layerPositionTypeHorizontal = getLayerMetadata(kPositionTypeHorizontal);    var layerPositionTypeVertical = getLayerMetadata(kPositionTypeVertical);        ret['name'] = layerName;    ret['id'] = layerID;    ret['class'] = layerClass;    ret['misc'] = layerMisc;    ret['rect'] = layerRect;    ret['position'] = layerPosition;    ret['positionTypeHorizontal'] = layerPositionTypeHorizontal;    ret['positionTypeVertical'] = layerPositionTypeVertical;        // if the layer has effects, remove them //    var ref = new ActionReference();    ref.putEnumerated(charIDToTypeID("Lyr "), charIDToTypeID("Ordn"), charIDToTypeID("Trgt"));    var layerDescription = executeActionGet(ref);        var hadEffects = false;    if (layerDescription.hasKey(stringIDToTypeID('layerEffects')) && layerDescription.getBoolean(stringIDToTypeID('layerFXVisible')))    {        var fxDesc = layerDescription.getObjectValue(stringIDToTypeID('layerEffects'));        executeAction(charIDToTypeID("CpFX"), layerDescription, DialogModes.NO);        executeAction(charIDToTypeID("dlfx"), layerDescription, DialogModes.NO);        ret['rect'] = getRectStringFromLayer(node);        executeAction(charIDToTypeID("PaFX"), layerDescription, DialogModes.NO);        ret['effectsRect'] = getRectStringFromLayer(node);    }    ret['properties'] = {};    for (var i = 0; i < layerDescription.count; ++i)    {        var propertyID = layerDescription.getKey (i);        var propertyValue = getKeyValueFromActionDecriptor (layerDescription, propertyID);        ret['properties'][typeIDToStringID(propertyID)] = propertyValue;    }    if (node.typename == "LayerSet")    {        ret['children'] = [];        var layers = node.layers;        for (var i = 0; i < layers.length; ++i)        {            var child = layers[i];            if (child.visible)            {                ret['children'][ret['children'].length] = processNode(child, exportFolder);            }            else            {                log("Skipping layer: " + child.name);            }        }    }		return ret;}//----------------------------------------------------------------------------------------------------function getLayerMetadata(propertyName){    var propertyID = propertyName;    // initialize the XML to return to flash //    var ret = "";        if(!app.activeDocument.activeLayer.isBackgroundLayer && loadXMPLibrary())    {        var xmp;        // try to get the raw metadata from the layer, if there is an error, set the property to NULL and return //        try        { 			xmp = new XMPMeta(app.activeDocument.activeLayer.xmpMetadata.rawData);        }        catch(e)        {            unloadXMPLibrary();            //alert("ERROR: Reading Raw Meta");            return ret;        }                // try to get the property value //        var propertyValue;        try        {            propertyValue = xmp.getProperty(kXMPNamespace, propertyID).toString();        }        catch(e)        {            // if there was an error getting the layer type, set the property to NULL and return //            unloadXMPLibrary();            //alert("ERROR: Reading " + propertyID + " --> " + propertyName + " :: " + e);            return ret;        }                // write the layer type to the xml //        ret = propertyValue;    }	return ret;}//----------------------------------------------------------------------------------------------------function getKeyValueFromActionDecriptor( object, key ){    var elementType = object.getType (key);    var ret;    switch (elementType)    {        case DescValueType.ALIASTYPE:            ret = "ALIASTYPE";            break;                    case DescValueType.BOOLEANTYPE:            ret = object.getBoolean (key);            break;                    case DescValueType.CLASSTYPE:            ret = object.getClass (key);            break;                    case DescValueType.DOUBLETYPE:            ret = object.getDouble (key);            break;                    case DescValueType.ENUMERATEDTYPE:            ret = typeIDToStringID(object.getEnumerationValue (key));            break;                    case DescValueType.INTEGERTYPE:            ret = object.getInteger (key);            break;                    case DescValueType.LISTTYPE:            {                ret = [];                //ret = "{ ";                var elementList = object.getList (key);                for (var i = 0; i < elementList.count; ++i)                {                    ret[i] = getKeyValueFromActionDecriptor(elementList, i);                    //ret += "element" + i + ": { " + getKeyValueFromActionDecriptor(elementList, i) + " } \n";                }                //ret += "}\n\n";            }            break;                    case DescValueType.OBJECTTYPE:            {                ret = {};                //ret = "{ ";                var elementObject = object.getObjectValue (key);                for (var i = 0; i < elementObject.count; ++i)                {                    var elementKey = elementObject.getKey (i);                    ret[typeIDToStringID(elementKey)] = getKeyValueFromActionDecriptor(elementObject, elementKey);                    //ret += typeIDToStringID(elementKey) + ": { " + getKeyValueFromActionDecriptor(elementObject, elementKey) + " } \n";                }                //ret == "}\n\n";            }            break;                    case DescValueType.RAWTYPE:            ret = "RAWTYPE";            break;                    case DescValueType.REFERENCETYPE:            ret = object.getReference (key);            break;                    case DescValueType.STRINGTYPE:            ret = object.getString (key);            break;                    case DescValueType.UNITDOUBLE:            ret = object.getUnitDoubleValue (key);            break;                    default:            ret = "TYPENOTFOUND";            break;    }    return ret;}//----------------------------------------------------------------------------------------------------function printActionDescriptor( object ){    indent();    for (var i = 0; i < object.count; ++i)    {        var elementKey = object.getKey (i);        printKeyValueForActionDescription (object, elementKey);    }    outdent();}//----------------------------------------------------------------------------------------------------function printKeyValueForActionDescription( object, key ){    try     {        var elementType = object.getType (key);        if (elementType == DescValueType.OBJECTTYPE)        {            log ("Key: " + typeIDToStringID(key) + " Type: " + elementType + " Value: ");            printActionDescriptor (object.getObjectValue (key));        }        else if (elementType == DescValueType.LISTTYPE)        {            log ("Key: " + typeIDToStringID(key) + " Type: " + elementType + " Value: ");            indent();            var elementList = object.getList (key);            for (var i = 0; i < elementList.count; ++i)            {                printKeyValueForActionDescription (elementList, i);            }            outdent();        }        else        {            log ("Key: " + typeIDToStringID(key) + " Type: " + elementType + " Value: " + getKeyValueFromActionDecriptor(object, key));        }    }    catch (error)    {    }}//----------------------------------------------------------------------------------------------------function getRectStringFromLayer(layer){    var bounds = layer.bounds;    var ret = ("{ { " + bounds[0].as('px') + ", " + bounds[1].as('px') + " }, { " + (bounds[2].as('px') - bounds[0].as('px')) + ", " + (bounds[3].as('px') - bounds[1].as('px')) + " } }");    return ret;}/**	The function loads the XMP Script Library.	@returns True if the XMP Script Library was loaded successfully.	@type Boolean*/function loadXMPLibrary(){	if ( !ExternalObject.AdobeXMPScript ){		try{			ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');		}catch (e){			alert("Can't load XMP Script Library");			return false;		}	}	return true;}/**	The function unloads the XMP Script Library.*/function unloadXMPLibrary(){	if( ExternalObject.AdobeXMPScript ) {		try{			ExternalObject.AdobeXMPScript.unload();			ExternalObject.AdobeXMPScript = undefined;		}catch (e){			alert("Can't unload XMP Script Library");		}	}}//------------///////////////////////////////////------------////------------////// SUPPORTING FUNCTIONS ///////------------////------------///////////////////////////////////------------////----------------------------------------------------------------------------------------------------//